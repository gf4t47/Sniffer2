// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cell.proto

#ifndef PROTOBUF_cell_2eproto__INCLUDED
#define PROTOBUF_cell_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace filesystem {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cell_2eproto();
void protobuf_AssignDesc_cell_2eproto();
void protobuf_ShutdownFile_cell_2eproto();

class Coordinate;
class Cell;
class Cell_WindVector;
class Cell_Wind;
class Cell_Methane;
class Cells;

enum Cell_CellTag {
  Cell_CellTag_Air = 1,
  Cell_CellTag_Ground = 2,
  Cell_CellTag_Building = 3
};
bool Cell_CellTag_IsValid(int value);
const Cell_CellTag Cell_CellTag_CellTag_MIN = Cell_CellTag_Air;
const Cell_CellTag Cell_CellTag_CellTag_MAX = Cell_CellTag_Building;
const int Cell_CellTag_CellTag_ARRAYSIZE = Cell_CellTag_CellTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* Cell_CellTag_descriptor();
inline const ::std::string& Cell_CellTag_Name(Cell_CellTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    Cell_CellTag_descriptor(), value);
}
inline bool Cell_CellTag_Parse(
    const ::std::string& name, Cell_CellTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Cell_CellTag>(
    Cell_CellTag_descriptor(), name, value);
}
// ===================================================================

class Coordinate : public ::google::protobuf::Message {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  void Swap(Coordinate* other);

  // implements Message ----------------------------------------------

  Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 coord_item = 1;
  inline int coord_item_size() const;
  inline void clear_coord_item();
  static const int kCoordItemFieldNumber = 1;
  inline ::google::protobuf::int32 coord_item(int index) const;
  inline void set_coord_item(int index, ::google::protobuf::int32 value);
  inline void add_coord_item(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      coord_item() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_coord_item();

  // @@protoc_insertion_point(class_scope:filesystem.Coordinate)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > coord_item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cell_2eproto();
  friend void protobuf_AssignDesc_cell_2eproto();
  friend void protobuf_ShutdownFile_cell_2eproto();

  void InitAsDefaultInstance();
  static Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class Cell_WindVector : public ::google::protobuf::Message {
 public:
  Cell_WindVector();
  virtual ~Cell_WindVector();

  Cell_WindVector(const Cell_WindVector& from);

  inline Cell_WindVector& operator=(const Cell_WindVector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell_WindVector& default_instance();

  void Swap(Cell_WindVector* other);

  // implements Message ----------------------------------------------

  Cell_WindVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell_WindVector& from);
  void MergeFrom(const Cell_WindVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double wv_item = 1;
  inline int wv_item_size() const;
  inline void clear_wv_item();
  static const int kWvItemFieldNumber = 1;
  inline double wv_item(int index) const;
  inline void set_wv_item(int index, double value);
  inline void add_wv_item(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      wv_item() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_wv_item();

  // @@protoc_insertion_point(class_scope:filesystem.Cell.WindVector)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > wv_item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cell_2eproto();
  friend void protobuf_AssignDesc_cell_2eproto();
  friend void protobuf_ShutdownFile_cell_2eproto();

  void InitAsDefaultInstance();
  static Cell_WindVector* default_instance_;
};
// -------------------------------------------------------------------

class Cell_Wind : public ::google::protobuf::Message {
 public:
  Cell_Wind();
  virtual ~Cell_Wind();

  Cell_Wind(const Cell_Wind& from);

  inline Cell_Wind& operator=(const Cell_Wind& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell_Wind& default_instance();

  void Swap(Cell_Wind* other);

  // implements Message ----------------------------------------------

  Cell_Wind* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell_Wind& from);
  void MergeFrom(const Cell_Wind& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .filesystem.Cell.WindVector wind = 1;
  inline bool has_wind() const;
  inline void clear_wind();
  static const int kWindFieldNumber = 1;
  inline const ::filesystem::Cell_WindVector& wind() const;
  inline ::filesystem::Cell_WindVector* mutable_wind();
  inline ::filesystem::Cell_WindVector* release_wind();
  inline void set_allocated_wind(::filesystem::Cell_WindVector* wind);

  // required .filesystem.Cell.WindVector potential = 2;
  inline bool has_potential() const;
  inline void clear_potential();
  static const int kPotentialFieldNumber = 2;
  inline const ::filesystem::Cell_WindVector& potential() const;
  inline ::filesystem::Cell_WindVector* mutable_potential();
  inline ::filesystem::Cell_WindVector* release_potential();
  inline void set_allocated_potential(::filesystem::Cell_WindVector* potential);

  // @@protoc_insertion_point(class_scope:filesystem.Cell.Wind)
 private:
  inline void set_has_wind();
  inline void clear_has_wind();
  inline void set_has_potential();
  inline void clear_has_potential();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::filesystem::Cell_WindVector* wind_;
  ::filesystem::Cell_WindVector* potential_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cell_2eproto();
  friend void protobuf_AssignDesc_cell_2eproto();
  friend void protobuf_ShutdownFile_cell_2eproto();

  void InitAsDefaultInstance();
  static Cell_Wind* default_instance_;
};
// -------------------------------------------------------------------

class Cell_Methane : public ::google::protobuf::Message {
 public:
  Cell_Methane();
  virtual ~Cell_Methane();

  Cell_Methane(const Cell_Methane& from);

  inline Cell_Methane& operator=(const Cell_Methane& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell_Methane& default_instance();

  void Swap(Cell_Methane* other);

  // implements Message ----------------------------------------------

  Cell_Methane* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell_Methane& from);
  void MergeFrom(const Cell_Methane& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double concentration = 1;
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 1;
  inline double concentration() const;
  inline void set_concentration(double value);

  // @@protoc_insertion_point(class_scope:filesystem.Cell.Methane)
 private:
  inline void set_has_concentration();
  inline void clear_has_concentration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double concentration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cell_2eproto();
  friend void protobuf_AssignDesc_cell_2eproto();
  friend void protobuf_ShutdownFile_cell_2eproto();

  void InitAsDefaultInstance();
  static Cell_Methane* default_instance_;
};
// -------------------------------------------------------------------

class Cell : public ::google::protobuf::Message {
 public:
  Cell();
  virtual ~Cell();

  Cell(const Cell& from);

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cell& default_instance();

  void Swap(Cell* other);

  // implements Message ----------------------------------------------

  Cell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cell& from);
  void MergeFrom(const Cell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Cell_WindVector WindVector;
  typedef Cell_Wind Wind;
  typedef Cell_Methane Methane;

  typedef Cell_CellTag CellTag;
  static const CellTag Air = Cell_CellTag_Air;
  static const CellTag Ground = Cell_CellTag_Ground;
  static const CellTag Building = Cell_CellTag_Building;
  static inline bool CellTag_IsValid(int value) {
    return Cell_CellTag_IsValid(value);
  }
  static const CellTag CellTag_MIN =
    Cell_CellTag_CellTag_MIN;
  static const CellTag CellTag_MAX =
    Cell_CellTag_CellTag_MAX;
  static const int CellTag_ARRAYSIZE =
    Cell_CellTag_CellTag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CellTag_descriptor() {
    return Cell_CellTag_descriptor();
  }
  static inline const ::std::string& CellTag_Name(CellTag value) {
    return Cell_CellTag_Name(value);
  }
  static inline bool CellTag_Parse(const ::std::string& name,
      CellTag* value) {
    return Cell_CellTag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .filesystem.Coordinate coord = 1;
  inline bool has_coord() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 1;
  inline const ::filesystem::Coordinate& coord() const;
  inline ::filesystem::Coordinate* mutable_coord();
  inline ::filesystem::Coordinate* release_coord();
  inline void set_allocated_coord(::filesystem::Coordinate* coord);

  // required .filesystem.Cell.CellTag tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline ::filesystem::Cell_CellTag tag() const;
  inline void set_tag(::filesystem::Cell_CellTag value);

  // required .filesystem.Cell.Methane mtn = 3;
  inline bool has_mtn() const;
  inline void clear_mtn();
  static const int kMtnFieldNumber = 3;
  inline const ::filesystem::Cell_Methane& mtn() const;
  inline ::filesystem::Cell_Methane* mutable_mtn();
  inline ::filesystem::Cell_Methane* release_mtn();
  inline void set_allocated_mtn(::filesystem::Cell_Methane* mtn);

  // required .filesystem.Cell.Wind wind = 4;
  inline bool has_wind() const;
  inline void clear_wind();
  static const int kWindFieldNumber = 4;
  inline const ::filesystem::Cell_Wind& wind() const;
  inline ::filesystem::Cell_Wind* mutable_wind();
  inline ::filesystem::Cell_Wind* release_wind();
  inline void set_allocated_wind(::filesystem::Cell_Wind* wind);

  // @@protoc_insertion_point(class_scope:filesystem.Cell)
 private:
  inline void set_has_coord();
  inline void clear_has_coord();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_mtn();
  inline void clear_has_mtn();
  inline void set_has_wind();
  inline void clear_has_wind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::filesystem::Coordinate* coord_;
  ::filesystem::Cell_Methane* mtn_;
  ::filesystem::Cell_Wind* wind_;
  int tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cell_2eproto();
  friend void protobuf_AssignDesc_cell_2eproto();
  friend void protobuf_ShutdownFile_cell_2eproto();

  void InitAsDefaultInstance();
  static Cell* default_instance_;
};
// -------------------------------------------------------------------

class Cells : public ::google::protobuf::Message {
 public:
  Cells();
  virtual ~Cells();

  Cells(const Cells& from);

  inline Cells& operator=(const Cells& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cells& default_instance();

  void Swap(Cells* other);

  // implements Message ----------------------------------------------

  Cells* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cells& from);
  void MergeFrom(const Cells& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .filesystem.Cell cell = 1;
  inline int cell_size() const;
  inline void clear_cell();
  static const int kCellFieldNumber = 1;
  inline const ::filesystem::Cell& cell(int index) const;
  inline ::filesystem::Cell* mutable_cell(int index);
  inline ::filesystem::Cell* add_cell();
  inline const ::google::protobuf::RepeatedPtrField< ::filesystem::Cell >&
      cell() const;
  inline ::google::protobuf::RepeatedPtrField< ::filesystem::Cell >*
      mutable_cell();

  // @@protoc_insertion_point(class_scope:filesystem.Cells)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::filesystem::Cell > cell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cell_2eproto();
  friend void protobuf_AssignDesc_cell_2eproto();
  friend void protobuf_ShutdownFile_cell_2eproto();

  void InitAsDefaultInstance();
  static Cells* default_instance_;
};
// ===================================================================


// ===================================================================

// Coordinate

// repeated int32 coord_item = 1;
inline int Coordinate::coord_item_size() const {
  return coord_item_.size();
}
inline void Coordinate::clear_coord_item() {
  coord_item_.Clear();
}
inline ::google::protobuf::int32 Coordinate::coord_item(int index) const {
  return coord_item_.Get(index);
}
inline void Coordinate::set_coord_item(int index, ::google::protobuf::int32 value) {
  coord_item_.Set(index, value);
}
inline void Coordinate::add_coord_item(::google::protobuf::int32 value) {
  coord_item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Coordinate::coord_item() const {
  return coord_item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Coordinate::mutable_coord_item() {
  return &coord_item_;
}

// -------------------------------------------------------------------

// Cell_WindVector

// repeated double wv_item = 1;
inline int Cell_WindVector::wv_item_size() const {
  return wv_item_.size();
}
inline void Cell_WindVector::clear_wv_item() {
  wv_item_.Clear();
}
inline double Cell_WindVector::wv_item(int index) const {
  return wv_item_.Get(index);
}
inline void Cell_WindVector::set_wv_item(int index, double value) {
  wv_item_.Set(index, value);
}
inline void Cell_WindVector::add_wv_item(double value) {
  wv_item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Cell_WindVector::wv_item() const {
  return wv_item_;
}
inline ::google::protobuf::RepeatedField< double >*
Cell_WindVector::mutable_wv_item() {
  return &wv_item_;
}

// -------------------------------------------------------------------

// Cell_Wind

// required .filesystem.Cell.WindVector wind = 1;
inline bool Cell_Wind::has_wind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cell_Wind::set_has_wind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cell_Wind::clear_has_wind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cell_Wind::clear_wind() {
  if (wind_ != NULL) wind_->::filesystem::Cell_WindVector::Clear();
  clear_has_wind();
}
inline const ::filesystem::Cell_WindVector& Cell_Wind::wind() const {
  return wind_ != NULL ? *wind_ : *default_instance_->wind_;
}
inline ::filesystem::Cell_WindVector* Cell_Wind::mutable_wind() {
  set_has_wind();
  if (wind_ == NULL) wind_ = new ::filesystem::Cell_WindVector;
  return wind_;
}
inline ::filesystem::Cell_WindVector* Cell_Wind::release_wind() {
  clear_has_wind();
  ::filesystem::Cell_WindVector* temp = wind_;
  wind_ = NULL;
  return temp;
}
inline void Cell_Wind::set_allocated_wind(::filesystem::Cell_WindVector* wind) {
  delete wind_;
  wind_ = wind;
  if (wind) {
    set_has_wind();
  } else {
    clear_has_wind();
  }
}

// required .filesystem.Cell.WindVector potential = 2;
inline bool Cell_Wind::has_potential() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cell_Wind::set_has_potential() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cell_Wind::clear_has_potential() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cell_Wind::clear_potential() {
  if (potential_ != NULL) potential_->::filesystem::Cell_WindVector::Clear();
  clear_has_potential();
}
inline const ::filesystem::Cell_WindVector& Cell_Wind::potential() const {
  return potential_ != NULL ? *potential_ : *default_instance_->potential_;
}
inline ::filesystem::Cell_WindVector* Cell_Wind::mutable_potential() {
  set_has_potential();
  if (potential_ == NULL) potential_ = new ::filesystem::Cell_WindVector;
  return potential_;
}
inline ::filesystem::Cell_WindVector* Cell_Wind::release_potential() {
  clear_has_potential();
  ::filesystem::Cell_WindVector* temp = potential_;
  potential_ = NULL;
  return temp;
}
inline void Cell_Wind::set_allocated_potential(::filesystem::Cell_WindVector* potential) {
  delete potential_;
  potential_ = potential;
  if (potential) {
    set_has_potential();
  } else {
    clear_has_potential();
  }
}

// -------------------------------------------------------------------

// Cell_Methane

// required double concentration = 1;
inline bool Cell_Methane::has_concentration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cell_Methane::set_has_concentration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cell_Methane::clear_has_concentration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cell_Methane::clear_concentration() {
  concentration_ = 0;
  clear_has_concentration();
}
inline double Cell_Methane::concentration() const {
  return concentration_;
}
inline void Cell_Methane::set_concentration(double value) {
  set_has_concentration();
  concentration_ = value;
}

// -------------------------------------------------------------------

// Cell

// required .filesystem.Coordinate coord = 1;
inline bool Cell::has_coord() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cell::set_has_coord() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cell::clear_has_coord() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cell::clear_coord() {
  if (coord_ != NULL) coord_->::filesystem::Coordinate::Clear();
  clear_has_coord();
}
inline const ::filesystem::Coordinate& Cell::coord() const {
  return coord_ != NULL ? *coord_ : *default_instance_->coord_;
}
inline ::filesystem::Coordinate* Cell::mutable_coord() {
  set_has_coord();
  if (coord_ == NULL) coord_ = new ::filesystem::Coordinate;
  return coord_;
}
inline ::filesystem::Coordinate* Cell::release_coord() {
  clear_has_coord();
  ::filesystem::Coordinate* temp = coord_;
  coord_ = NULL;
  return temp;
}
inline void Cell::set_allocated_coord(::filesystem::Coordinate* coord) {
  delete coord_;
  coord_ = coord;
  if (coord) {
    set_has_coord();
  } else {
    clear_has_coord();
  }
}

// required .filesystem.Cell.CellTag tag = 2;
inline bool Cell::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cell::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cell::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cell::clear_tag() {
  tag_ = 1;
  clear_has_tag();
}
inline ::filesystem::Cell_CellTag Cell::tag() const {
  return static_cast< ::filesystem::Cell_CellTag >(tag_);
}
inline void Cell::set_tag(::filesystem::Cell_CellTag value) {
  assert(::filesystem::Cell_CellTag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// required .filesystem.Cell.Methane mtn = 3;
inline bool Cell::has_mtn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cell::set_has_mtn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cell::clear_has_mtn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cell::clear_mtn() {
  if (mtn_ != NULL) mtn_->::filesystem::Cell_Methane::Clear();
  clear_has_mtn();
}
inline const ::filesystem::Cell_Methane& Cell::mtn() const {
  return mtn_ != NULL ? *mtn_ : *default_instance_->mtn_;
}
inline ::filesystem::Cell_Methane* Cell::mutable_mtn() {
  set_has_mtn();
  if (mtn_ == NULL) mtn_ = new ::filesystem::Cell_Methane;
  return mtn_;
}
inline ::filesystem::Cell_Methane* Cell::release_mtn() {
  clear_has_mtn();
  ::filesystem::Cell_Methane* temp = mtn_;
  mtn_ = NULL;
  return temp;
}
inline void Cell::set_allocated_mtn(::filesystem::Cell_Methane* mtn) {
  delete mtn_;
  mtn_ = mtn;
  if (mtn) {
    set_has_mtn();
  } else {
    clear_has_mtn();
  }
}

// required .filesystem.Cell.Wind wind = 4;
inline bool Cell::has_wind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cell::set_has_wind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cell::clear_has_wind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cell::clear_wind() {
  if (wind_ != NULL) wind_->::filesystem::Cell_Wind::Clear();
  clear_has_wind();
}
inline const ::filesystem::Cell_Wind& Cell::wind() const {
  return wind_ != NULL ? *wind_ : *default_instance_->wind_;
}
inline ::filesystem::Cell_Wind* Cell::mutable_wind() {
  set_has_wind();
  if (wind_ == NULL) wind_ = new ::filesystem::Cell_Wind;
  return wind_;
}
inline ::filesystem::Cell_Wind* Cell::release_wind() {
  clear_has_wind();
  ::filesystem::Cell_Wind* temp = wind_;
  wind_ = NULL;
  return temp;
}
inline void Cell::set_allocated_wind(::filesystem::Cell_Wind* wind) {
  delete wind_;
  wind_ = wind;
  if (wind) {
    set_has_wind();
  } else {
    clear_has_wind();
  }
}

// -------------------------------------------------------------------

// Cells

// repeated .filesystem.Cell cell = 1;
inline int Cells::cell_size() const {
  return cell_.size();
}
inline void Cells::clear_cell() {
  cell_.Clear();
}
inline const ::filesystem::Cell& Cells::cell(int index) const {
  return cell_.Get(index);
}
inline ::filesystem::Cell* Cells::mutable_cell(int index) {
  return cell_.Mutable(index);
}
inline ::filesystem::Cell* Cells::add_cell() {
  return cell_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::filesystem::Cell >&
Cells::cell() const {
  return cell_;
}
inline ::google::protobuf::RepeatedPtrField< ::filesystem::Cell >*
Cells::mutable_cell() {
  return &cell_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace filesystem

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::filesystem::Cell_CellTag>() {
  return ::filesystem::Cell_CellTag_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cell_2eproto__INCLUDED
